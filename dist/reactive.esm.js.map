{
  "version": 3,
  "sources": ["../src/reactive/signals.js"],
  "sourcesContent": ["// src/reactive/signals.js\n// Improved reactive primitives with dependency tracking, cleanup and disposers.\n// - createSignal: [get, set, subscribe]\n// - createEffect(fn): returns disposer()\n// - createComputed(fn): returns getter that caches and invalidates automatically\n// - $state: proxy that participates in dependency tracking per-property\n\nconst EFFECT_STACK = []; // stack of active effect runners\nconst EFFECT_DEPS = new WeakMap(); // Map<runner, Set<signalKey>>\n\n/**\n * Internal helper: track that `runner` depends on `signalKey`.\n * signalKey is any object with a __subs Set (e.g. a getter function or a property signal object).\n */\nfunction _trackDependency(runner, signalKey) {\n  if (!runner || !signalKey) return;\n  if (!signalKey.__subs) signalKey.__subs = new Set();\n  if (!signalKey.__subs.has(runner)) {\n    signalKey.__subs.add(runner);\n  }\n\n  let deps = EFFECT_DEPS.get(runner);\n  if (!deps) {\n    deps = new Set();\n    EFFECT_DEPS.set(runner, deps);\n  }\n  deps.add(signalKey);\n}\n\n/**\n * createSignal(initial)\n * returns [get, set, subscribe]\n */\nexport function createSignal(initial) {\n  let value = initial;\n  const subs = new Set(); // user subscribers and effect runners will be stored here\n\n  function get() {\n    const active = EFFECT_STACK[EFFECT_STACK.length - 1];\n    if (active) {\n      _trackDependency(active, get);\n    }\n    return value;\n  }\n\n  // attach __subs so tracking code can use it\n  get.__subs = subs;\n\n  function set(newVal) {\n    const old = value;\n    if (typeof newVal === 'function') {\n      value = newVal(value);\n    } else {\n      value = newVal;\n    }\n    if (old === value) return value;\n\n    // notify subscribers (copy to avoid mutation during iteration)\n    const arr = Array.from(subs);\n    arr.forEach((fn) => {\n      try { fn(); } catch (err) { setTimeout(() => { throw err; }); }\n    });\n    return value;\n  }\n\n  function subscribe(fn) {\n    if (typeof fn !== 'function') return () => {};\n    subs.add(fn);\n    return () => subs.delete(fn);\n  }\n\n  return [get, set, subscribe];\n}\n\n/**\n * createEffect(fn)\n * - runs fn immediately and whenever its dependencies change\n * - supports cleanup: if fn returns a function, it will be called before next run and on dispose\n * - returns a disposer function to stop the effect and clean up subscriptions\n */\nexport function createEffect(fn) {\n  if (typeof fn !== 'function') throw new Error('createEffect: fn must be a function');\n\n  let cleanup = null;\n\n  const runner = () => {\n    // remove previous subscriptions for this runner\n    const prevDeps = EFFECT_DEPS.get(runner);\n    if (prevDeps) {\n      prevDeps.forEach((sigKey) => {\n        try { sigKey.__subs && sigKey.__subs.delete(runner); } catch (_) {}\n      });\n      EFFECT_DEPS.delete(runner);\n    }\n\n    // execute previous cleanup\n    try { if (typeof cleanup === 'function') cleanup(); } catch (err) { console.error(err); }\n    cleanup = null;\n\n    // run effect and collect dependencies\n    EFFECT_STACK.push(runner);\n    try {\n      const maybeCleanup = fn();\n      if (typeof maybeCleanup === 'function') cleanup = maybeCleanup;\n    } catch (err) {\n      console.error('createEffect error', err);\n    } finally {\n      EFFECT_STACK.pop();\n    }\n  };\n\n  // initial run\n  runner();\n\n  // return disposer\n  return () => {\n    const deps = EFFECT_DEPS.get(runner);\n    if (deps) {\n      deps.forEach((sigKey) => {\n        try { sigKey.__subs && sigKey.__subs.delete(runner); } catch (_) {}\n      });\n      EFFECT_DEPS.delete(runner);\n    }\n    try { if (typeof cleanup === 'function') cleanup(); } catch (err) { console.error(err); }\n    cleanup = null;\n  };\n}\n\n/**\n * createComputed(fn)\n * - returns a getter function that caches the computed value\n * - when dependencies change it marks dirty; the next call recomputes\n */\nexport function createComputed(fn) {\n  if (typeof fn !== 'function') throw new Error('createComputed: fn must be a function');\n\n  let cached;\n  let dirty = true;\n  let cleanup = null;\n\n  const recompute = () => {\n    // remove prev deps\n    const prevDeps = EFFECT_DEPS.get(recompute);\n    if (prevDeps) {\n      prevDeps.forEach((sigKey) => {\n        try { sigKey.__subs && sigKey.__subs.delete(recompute); } catch (_) {}\n      });\n      EFFECT_DEPS.delete(recompute);\n    }\n    try { if (typeof cleanup === 'function') cleanup(); } catch (_) {}\n    cleanup = null;\n\n    EFFECT_STACK.push(recompute);\n    try {\n      const result = fn();\n      if (typeof result === 'function') {\n        // compute returned a cleanup function\n        cleanup = result;\n      } else {\n        cached = result;\n      }\n      dirty = false;\n    } catch (err) {\n      console.error('createComputed error', err);\n    } finally {\n      EFFECT_STACK.pop();\n    }\n  };\n\n  // initial compute\n  recompute();\n\n  // getter\n  return () => {\n    if (dirty) recompute();\n    return cached;\n  };\n}\n\n/**\n * $state implementation that participates in dependency tracking per property.\n *\n * Implementation details:\n * - For each proxied target object we keep a Map of property -> signalKey object.\n * - signalKey is a plain object with a __subs Set that stores effect runners (functions).\n * - When a property is read inside an active effect, we call _trackDependency(activeRunner, signalKey).\n * - When a property is set or deleted, we notify signalKey.__subs by calling each runner.\n * - Additionally, the returned proxy exposes a .subscribe(fn) that behaves like before:\n *   fn(key, oldVal, newVal) will be called for any property change.\n */\n\nconst STATE_PROP_SIGNALS = new WeakMap(); // Map<target, Map<prop, signalKey>>\n\nfunction _ensurePropSignalFor(target, prop) {\n  let map = STATE_PROP_SIGNALS.get(target);\n  if (!map) {\n    map = new Map();\n    STATE_PROP_SIGNALS.set(target, map);\n  }\n  let sig = map.get(prop);\n  if (!sig) {\n    sig = { __subs: new Set() }; // subscribers (effect runners)\n    map.set(prop, sig);\n  }\n  return sig;\n}\n\nexport function $state(initial = {}) {\n  const globalSubs = new Set();\n\n  const notifyGlobal = (key, oldVal, newVal) => {\n    globalSubs.forEach(fn => {\n      try { fn(key, oldVal, newVal); } catch (err) { console.error(err); }\n    });\n  };\n\n  const handler = {\n    get(target, prop, receiver) {\n      if (prop === '__isState') return true;\n      if (prop === 'subscribe') return (fn) => { globalSubs.add(fn); return () => globalSubs.delete(fn); };\n      if (prop === 'inspect') return () => Object.assign({}, target);\n\n      // tracking: if inside an effect, register dependency on this property\n      const active = EFFECT_STACK[EFFECT_STACK.length - 1];\n      if (active && typeof prop === 'string') {\n        const sig = _ensurePropSignalFor(target, prop);\n        _trackDependency(active, sig);\n      }\n\n      // normal property access\n      return Reflect.get(target, prop, receiver);\n    },\n\n    set(target, prop, value, receiver) {\n      const old = target[prop];\n      if (old === value) { target[prop] = value; return true; }\n      const result = Reflect.set(target, prop, value, receiver);\n\n      // notify property-specific subscribers (effect runners)\n      const map = STATE_PROP_SIGNALS.get(target);\n      if (map) {\n        const sig = map.get(prop);\n        if (sig && sig.__subs) {\n          Array.from(sig.__subs).forEach((runner) => {\n            try { runner(); } catch (err) { setTimeout(() => { throw err; }); }\n          });\n        }\n      }\n\n      // notify global subscribers\n      notifyGlobal(prop, old, value);\n      return result;\n    },\n\n    deleteProperty(target, prop) {\n      const old = target[prop];\n      const existed = prop in target;\n      const result = Reflect.deleteProperty(target, prop);\n\n      if (existed) {\n        // notify property-specific subscribers\n        const map = STATE_PROP_SIGNALS.get(target);\n        if (map) {\n          const sig = map.get(prop);\n          if (sig && sig.__subs) {\n            Array.from(sig.__subs).forEach((runner) => {\n              try { runner(); } catch (err) { setTimeout(() => { throw err; }); }\n            });\n          }\n          map.delete(prop);\n        }\n\n        // global subscribers\n        notifyGlobal(prop, old, undefined);\n      }\n      return result;\n    }\n  };\n\n  return new Proxy(Object.assign({}, initial), handler);\n}\n\nexport default {\n  createSignal,\n  createEffect,\n  createComputed,\n  $state\n};\n"],
  "mappings": "AAOA,MAAMA,EAAe,CAAC,EAChBC,EAAc,IAAI,QAMxB,SAASC,EAAiBC,EAAQC,EAAW,CAC3C,GAAI,CAACD,GAAU,CAACC,EAAW,OACtBA,EAAU,SAAQA,EAAU,OAAS,IAAI,KACzCA,EAAU,OAAO,IAAID,CAAM,GAC9BC,EAAU,OAAO,IAAID,CAAM,EAG7B,IAAIE,EAAOJ,EAAY,IAAIE,CAAM,EAC5BE,IACHA,EAAO,IAAI,IACXJ,EAAY,IAAIE,EAAQE,CAAI,GAE9BA,EAAK,IAAID,CAAS,CACpB,CAMO,SAASE,EAAaC,EAAS,CACpC,IAAIC,EAAQD,EACZ,MAAME,EAAO,IAAI,IAEjB,SAASC,GAAM,CACb,MAAMC,EAASX,EAAaA,EAAa,OAAS,CAAC,EACnD,OAAIW,GACFT,EAAiBS,EAAQD,CAAG,EAEvBF,CACT,CAGAE,EAAI,OAASD,EAEb,SAASG,EAAIC,EAAQ,CACnB,MAAMC,EAAMN,EAMZ,OALI,OAAOK,GAAW,WACpBL,EAAQK,EAAOL,CAAK,EAEpBA,EAAQK,EAENC,IAAQN,GAGA,MAAM,KAAKC,CAAI,EACvB,QAASM,GAAO,CAClB,GAAI,CAAEA,EAAG,CAAG,OAASC,EAAK,CAAE,WAAW,IAAM,CAAE,MAAMA,CAAK,CAAC,CAAG,CAChE,CAAC,EACMR,CACT,CAEA,SAASS,EAAUF,EAAI,CACrB,OAAI,OAAOA,GAAO,WAAmB,IAAM,CAAC,GAC5CN,EAAK,IAAIM,CAAE,EACJ,IAAMN,EAAK,OAAOM,CAAE,EAC7B,CAEA,MAAO,CAACL,EAAKE,EAAKK,CAAS,CAC7B,CAQO,SAASC,EAAaH,EAAI,CAC/B,GAAI,OAAOA,GAAO,WAAY,MAAM,IAAI,MAAM,qCAAqC,EAEnF,IAAII,EAAU,KAEd,MAAMhB,EAAS,IAAM,CAEnB,MAAMiB,EAAWnB,EAAY,IAAIE,CAAM,EACnCiB,IACFA,EAAS,QAASC,GAAW,CAC3B,GAAI,CAAEA,EAAO,QAAUA,EAAO,OAAO,OAAOlB,CAAM,CAAG,MAAY,CAAC,CACpE,CAAC,EACDF,EAAY,OAAOE,CAAM,GAI3B,GAAI,CAAM,OAAOgB,GAAY,YAAYA,EAAQ,CAAG,OAASH,EAAK,CAAE,QAAQ,MAAMA,CAAG,CAAG,CACxFG,EAAU,KAGVnB,EAAa,KAAKG,CAAM,EACxB,GAAI,CACF,MAAMmB,EAAeP,EAAG,EACpB,OAAOO,GAAiB,aAAYH,EAAUG,EACpD,OAASN,EAAK,CACZ,QAAQ,MAAM,qBAAsBA,CAAG,CACzC,QAAE,CACAhB,EAAa,IAAI,CACnB,CACF,EAGA,OAAAG,EAAO,EAGA,IAAM,CACX,MAAME,EAAOJ,EAAY,IAAIE,CAAM,EAC/BE,IACFA,EAAK,QAASgB,GAAW,CACvB,GAAI,CAAEA,EAAO,QAAUA,EAAO,OAAO,OAAOlB,CAAM,CAAG,MAAY,CAAC,CACpE,CAAC,EACDF,EAAY,OAAOE,CAAM,GAE3B,GAAI,CAAM,OAAOgB,GAAY,YAAYA,EAAQ,CAAG,OAASH,EAAK,CAAE,QAAQ,MAAMA,CAAG,CAAG,CACxFG,EAAU,IACZ,CACF,CAOO,SAASI,EAAeR,EAAI,CACjC,GAAI,OAAOA,GAAO,WAAY,MAAM,IAAI,MAAM,uCAAuC,EAErF,IAAIS,EACAC,EAAQ,GACRN,EAAU,KAEd,MAAMO,EAAY,IAAM,CAEtB,MAAMN,EAAWnB,EAAY,IAAIyB,CAAS,EACtCN,IACFA,EAAS,QAASC,GAAW,CAC3B,GAAI,CAAEA,EAAO,QAAUA,EAAO,OAAO,OAAOK,CAAS,CAAG,MAAY,CAAC,CACvE,CAAC,EACDzB,EAAY,OAAOyB,CAAS,GAE9B,GAAI,CAAM,OAAOP,GAAY,YAAYA,EAAQ,CAAG,MAAY,CAAC,CACjEA,EAAU,KAEVnB,EAAa,KAAK0B,CAAS,EAC3B,GAAI,CACF,MAAMC,EAASZ,EAAG,EACd,OAAOY,GAAW,WAEpBR,EAAUQ,EAEVH,EAASG,EAEXF,EAAQ,EACV,OAAST,EAAK,CACZ,QAAQ,MAAM,uBAAwBA,CAAG,CAC3C,QAAE,CACAhB,EAAa,IAAI,CACnB,CACF,EAGA,OAAA0B,EAAU,EAGH,KACDD,GAAOC,EAAU,EACdF,EAEX,CAcA,MAAMI,EAAqB,IAAI,QAE/B,SAASC,EAAqBC,EAAQC,EAAM,CAC1C,IAAIC,EAAMJ,EAAmB,IAAIE,CAAM,EAClCE,IACHA,EAAM,IAAI,IACVJ,EAAmB,IAAIE,EAAQE,CAAG,GAEpC,IAAIC,EAAMD,EAAI,IAAID,CAAI,EACtB,OAAKE,IACHA,EAAM,CAAE,OAAQ,IAAI,GAAM,EAC1BD,EAAI,IAAID,EAAME,CAAG,GAEZA,CACT,CAEO,SAASC,EAAO3B,EAAU,CAAC,EAAG,CACnC,MAAM4B,EAAa,IAAI,IAEjBC,EAAe,CAACC,EAAKC,EAAQzB,IAAW,CAC5CsB,EAAW,QAAQpB,GAAM,CACvB,GAAI,CAAEA,EAAGsB,EAAKC,EAAQzB,CAAM,CAAG,OAASG,EAAK,CAAE,QAAQ,MAAMA,CAAG,CAAG,CACrE,CAAC,CACH,EAEMuB,EAAU,CACd,IAAIT,EAAQC,EAAMS,EAAU,CAC1B,GAAIT,IAAS,YAAa,MAAO,GACjC,GAAIA,IAAS,YAAa,OAAQhB,IAASoB,EAAW,IAAIpB,CAAE,EAAU,IAAMoB,EAAW,OAAOpB,CAAE,GAChG,GAAIgB,IAAS,UAAW,MAAO,IAAM,OAAO,OAAO,CAAC,EAAGD,CAAM,EAG7D,MAAMnB,EAASX,EAAaA,EAAa,OAAS,CAAC,EACnD,GAAIW,GAAU,OAAOoB,GAAS,SAAU,CACtC,MAAME,EAAMJ,EAAqBC,EAAQC,CAAI,EAC7C7B,EAAiBS,EAAQsB,CAAG,CAC9B,CAGA,OAAO,QAAQ,IAAIH,EAAQC,EAAMS,CAAQ,CAC3C,EAEA,IAAIV,EAAQC,EAAMvB,EAAOgC,EAAU,CACjC,MAAM1B,EAAMgB,EAAOC,CAAI,EACvB,GAAIjB,IAAQN,EAAS,OAAAsB,EAAOC,CAAI,EAAIvB,EAAc,GAClD,MAAMmB,EAAS,QAAQ,IAAIG,EAAQC,EAAMvB,EAAOgC,CAAQ,EAGlDR,EAAMJ,EAAmB,IAAIE,CAAM,EACzC,GAAIE,EAAK,CACP,MAAMC,EAAMD,EAAI,IAAID,CAAI,EACpBE,GAAOA,EAAI,QACb,MAAM,KAAKA,EAAI,MAAM,EAAE,QAAS9B,GAAW,CACzC,GAAI,CAAEA,EAAO,CAAG,OAASa,EAAK,CAAE,WAAW,IAAM,CAAE,MAAMA,CAAK,CAAC,CAAG,CACpE,CAAC,CAEL,CAGA,OAAAoB,EAAaL,EAAMjB,EAAKN,CAAK,EACtBmB,CACT,EAEA,eAAeG,EAAQC,EAAM,CAC3B,MAAMjB,EAAMgB,EAAOC,CAAI,EACjBU,EAAUV,KAAQD,EAClBH,EAAS,QAAQ,eAAeG,EAAQC,CAAI,EAElD,GAAIU,EAAS,CAEX,MAAMT,EAAMJ,EAAmB,IAAIE,CAAM,EACzC,GAAIE,EAAK,CACP,MAAMC,EAAMD,EAAI,IAAID,CAAI,EACpBE,GAAOA,EAAI,QACb,MAAM,KAAKA,EAAI,MAAM,EAAE,QAAS9B,GAAW,CACzC,GAAI,CAAEA,EAAO,CAAG,OAASa,EAAK,CAAE,WAAW,IAAM,CAAE,MAAMA,CAAK,CAAC,CAAG,CACpE,CAAC,EAEHgB,EAAI,OAAOD,CAAI,CACjB,CAGAK,EAAaL,EAAMjB,EAAK,MAAS,CACnC,CACA,OAAOa,CACT,CACF,EAEA,OAAO,IAAI,MAAM,OAAO,OAAO,CAAC,EAAGpB,CAAO,EAAGgC,CAAO,CACtD,CAEA,IAAOG,EAAQ,CACb,aAAApC,EACA,aAAAY,EACA,eAAAK,EACA,OAAAW,CACF",
  "names": ["EFFECT_STACK", "EFFECT_DEPS", "_trackDependency", "runner", "signalKey", "deps", "createSignal", "initial", "value", "subs", "get", "active", "set", "newVal", "old", "fn", "err", "subscribe", "createEffect", "cleanup", "prevDeps", "sigKey", "maybeCleanup", "createComputed", "cached", "dirty", "recompute", "result", "STATE_PROP_SIGNALS", "_ensurePropSignalFor", "target", "prop", "map", "sig", "$state", "globalSubs", "notifyGlobal", "key", "oldVal", "handler", "receiver", "existed", "signals_default"]
}
