const l=[],a=new WeakMap;function y(s,t){if(!s||!t)return;t.__subs||(t.__subs=new Set),t.__subs.has(s)||t.__subs.add(s);let n=a.get(s);n||(n=new Set,a.set(s,n)),n.add(t)}function m(s){let t=s;const n=new Set;function o(){const r=l[l.length-1];return r&&y(r,o),t}o.__subs=n;function e(r){const u=t;return typeof r=="function"?t=r(t):t=r,u===t||Array.from(n).forEach(_=>{try{_()}catch(i){setTimeout(()=>{throw i})}}),t}function c(r){return typeof r!="function"?()=>{}:(n.add(r),()=>n.delete(r))}return[o,e,c]}function p(s){if(typeof s!="function")throw new Error("createEffect: fn must be a function");let t=null;const n=()=>{const o=a.get(n);o&&(o.forEach(e=>{try{e.__subs&&e.__subs.delete(n)}catch{}}),a.delete(n));try{typeof t=="function"&&t()}catch(e){console.error(e)}t=null,l.push(n);try{const e=s();typeof e=="function"&&(t=e)}catch(e){console.error("createEffect error",e)}finally{l.pop()}};return n(),()=>{const o=a.get(n);o&&(o.forEach(e=>{try{e.__subs&&e.__subs.delete(n)}catch{}}),a.delete(n));try{typeof t=="function"&&t()}catch(e){console.error(e)}t=null}}function w(s){if(typeof s!="function")throw new Error("createComputed: fn must be a function");let t,n=!0,o=null;const e=()=>{const c=a.get(e);c&&(c.forEach(r=>{try{r.__subs&&r.__subs.delete(e)}catch{}}),a.delete(e));try{typeof o=="function"&&o()}catch{}o=null,l.push(e);try{const r=s();typeof r=="function"?o=r:t=r,n=!1}catch(r){console.error("createComputed error",r)}finally{l.pop()}};return e(),()=>(n&&e(),t)}const h=new WeakMap;function S(s,t){let n=h.get(s);n||(n=new Map,h.set(s,n));let o=n.get(t);return o||(o={__subs:new Set},n.set(t,o)),o}function g(s={}){const t=new Set,n=(e,c,r)=>{t.forEach(u=>{try{u(e,c,r)}catch(f){console.error(f)}})},o={get(e,c,r){if(c==="__isState")return!0;if(c==="subscribe")return f=>(t.add(f),()=>t.delete(f));if(c==="inspect")return()=>Object.assign({},e);const u=l[l.length-1];if(u&&typeof c=="string"){const f=S(e,c);y(u,f)}return Reflect.get(e,c,r)},set(e,c,r,u){const f=e[c];if(f===r)return e[c]=r,!0;const _=Reflect.set(e,c,r,u),i=h.get(e);if(i){const d=i.get(c);d&&d.__subs&&Array.from(d.__subs).forEach(b=>{try{b()}catch(E){setTimeout(()=>{throw E})}})}return n(c,f,r),_},deleteProperty(e,c){const r=e[c],u=c in e,f=Reflect.deleteProperty(e,c);if(u){const _=h.get(e);if(_){const i=_.get(c);i&&i.__subs&&Array.from(i.__subs).forEach(d=>{try{d()}catch(b){setTimeout(()=>{throw b})}}),_.delete(c)}n(c,r,void 0)}return f}};return new Proxy(Object.assign({},s),o)}var T={createSignal:m,createEffect:p,createComputed:w,$state:g};export{g as $state,w as createComputed,p as createEffect,m as createSignal,T as default};
//# sourceMappingURL=reactive.esm.js.map
